// Generated by CoffeeScript 1.7.1
define(['jquery', 'external/react', 'external/underscore', 'modules/core/i18n', 'modules/clean/activity/activity', 'modules/clean/activity/activity_local_storage', 'modules/clean/activity/activity_user', 'modules/clean/datetime', 'modules/clean/gandalf_util', 'modules/clean/react/button', 'modules/clean/react/file_comments/logger', 'modules/clean/react/image', 'modules/clean/react/react_i18n', 'modules/clean/react/sprite', 'modules/clean/react/activity/comment_activity_ui', 'modules/clean/react/activity/comment_input', 'modules/clean/react/file_comments/shared_link_signup_modals', 'modules/clean/static_urls'], function($j, React, $u, _arg, Activity, ActivityLocalStorage, ActivityUser, DateTime, GandalfUtil, ButtonClass, FileActivityClientLogger, ImageClass, ReactI18n, SpriteClass, CommentActivityUIClass, CommentInputClass, CommentsSharedLinkSignupModals, _arg1) {
  var CommentActivityUI, CommentInput, Image, R_, ReactCSSTransitionGroup, ThreadedCommentActivityUI, d, static_url, ungettext, _;
  _ = _arg._, ungettext = _arg.ungettext;
  static_url = _arg1.static_url;
  d = React.DOM;
  R_ = ReactI18n.R_;
  ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;
  CommentActivityUI = React.createFactory(CommentActivityUIClass);
  CommentInput = React.createFactory(CommentInputClass);
  Image = React.createFactory(ImageClass);
  ThreadedCommentActivityUI = React.createClass({
    displayName: "ThreadedCommentActivityUI",
    propTypes: {
      contextActivityStore: React.PropTypes.object.isRequired,
      commentActivity: React.PropTypes.object.isRequired,
      delete_comment: React.PropTypes.func.isRequired,
      user: React.PropTypes.object.isRequired,
      onAnnotationButtonMouseUp: React.PropTypes.func,
      fileViewerState: React.PropTypes.object,
      shouldAutoLinkify: React.PropTypes.bool,
      shouldUseSimpleModals: React.PropTypes.bool,
      shouldHidePhotoAvatars: React.PropTypes.bool,
      activity: React.PropTypes.object.isRequired,
      showResolvedComments: React.PropTypes.bool,
      contactSearchLogger: React.PropTypes.object,
      onInputFocus: React.PropTypes.func,
      onInputBlur: React.PropTypes.func,
      enableNoNotifyHint: React.PropTypes.bool,
      isCommentInputDisabled: React.PropTypes.bool,
      enableImport: React.PropTypes.bool,
      showNewComment: React.PropTypes.bool,
      isTinyAnnotationUIEnabled: React.PropTypes.bool,
      checkScroll: React.PropTypes.func,
      onAddCommentFromList: React.PropTypes.func,
      onAddSticker: React.PropTypes.func,
      onShowNewComment: React.PropTypes.func,
      onDeleteCommentFromList: React.PropTypes.func,
      onResolveCommentFromList: React.PropTypes.func,
      onLikeComment: React.PropTypes.func,
      onToggleShowResolvedComments: React.PropTypes.func,
      verifyAfterSignUpCallback: React.PropTypes.func
    },
    getInitialState: function() {
      return {
        shouldCollapsedReplies: true,
        isNewReplyLoading: false,
        shouldShowReplyInput: false
      };
    },
    getDefaultProps: function() {
      return {};
    },
    componentWillMount: function() {
      return this.lastCommentsCount = this.props.commentActivity.comment_activities.length;
    },
    componentWillReceiveProps: function(nextProps) {
      if (nextProps.commentActivity.comment_activities.length > this.lastCommentsCount && this.state.isNewReplyLoading) {
        this.lastCommentsCount = nextProps.commentActivity.comment_activities.length;
        return this.setState({
          isNewReplyLoading: false
        });
      }
    },
    onAddCommentFromList: function(text, metadata) {
      var _base;
      if (metadata == null) {
        metadata = {};
      }
      this.setState({
        isNewReplyLoading: true
      });
      return typeof (_base = this.props).onAddCommentFromList === "function" ? _base.onAddCommentFromList(text, metadata, this.props.commentActivity) : void 0;
    },
    onAddSticker: function(stickerId) {
      var _base;
      this.setState({
        isNewReplyLoading: true
      });
      return typeof (_base = this.props).onAddSticker === "function" ? _base.onAddSticker(stickerId) : void 0;
    },
    _verifyAfterSignUpCallback: function() {
      var _base;
      return typeof (_base = this.props).verifyAfterSignUpCallback === "function" ? _base.verifyAfterSignUpCallback() : void 0;
    },
    resizeCallback: function() {
      return this.forceUpdate();
    },
    onCancelComment: function() {
      return this.setState({
        shouldShowReplyInput: false
      });
    },
    onLikeComment: function(commentActivity) {
      var _base;
      return typeof (_base = this.props).onLikeComment === "function" ? _base.onLikeComment(commentActivity) : void 0;
    },
    onResolveCommentFromList: function(commentActivity, resolved) {
      var _base;
      return typeof (_base = this.props).onResolveCommentFromList === "function" ? _base.onResolveCommentFromList(commentActivity, resolved) : void 0;
    },
    onDeleteCommentFromList: function(commentActivity) {
      var _base;
      return typeof (_base = this.props).onDeleteCommentFromList === "function" ? _base.onDeleteCommentFromList(commentActivity) : void 0;
    },
    onAnnotationButtonMouseUp: function(commentActivity, commentMetdata) {
      var _base;
      return typeof (_base = this.props).onAnnotationButtonMouseUp === "function" ? _base.onAnnotationButtonMouseUp(commentActivity, commentMetdata) : void 0;
    },
    onReplyButtonMouseUp: function() {
      return this.setState({
        shouldShowReplyInput: !this.state.shouldShowReplyInput
      });
    },
    onToggleReplies: function(event) {
      return this.setState({
        shouldCollapsedReplies: false
      });
    },
    hasReplies: function() {
      return this.repliesCount() > 0;
    },
    repliesCount: function() {
      return this.props.commentActivity.comment_activities.length;
    },
    renderCommentActivityUI: function(ca, isReply, shouldShowReplyButton) {
      if (isReply == null) {
        isReply = false;
      }
      if (shouldShowReplyButton == null) {
        shouldShowReplyButton = false;
      }
      return CommentActivityUI({
        key: "threaded_comment_activity_ui_" + ca.activity_key,
        comment_activity: ca,
        context_activity_store: this.props.contextActivityStore,
        user: this.props.user,
        fileViewerState: this.props.fileViewerState,
        shouldUseSimpleModals: this.props.shouldUseSimpleModals,
        shouldHidePhotoAvatars: this.props.shouldHidePhotoAvatars,
        shouldShowReplyButton: shouldShowReplyButton,
        isTinyAnnotationUIEnabled: this.props.isTinyAnnotationUIEnabled,
        onLikeComment: this.onLikeComment,
        delete_comment: this.onDeleteCommentFromList,
        onAnnotationButtonMouseUp: this.onAnnotationButtonMouseUp,
        update_resolved: this.onResolveCommentFromList,
        shouldAutoLinkify: this.props.shouldAutoLinkify,
        isReply: isReply,
        onReplyButtonMouseUp: this.onReplyButtonMouseUp
      });
    },
    render: function() {
      var ca, comments, index, isLastComment, loadingSpinnerUI, num_resolved, _i, _len, _ref;
      loadingSpinnerUI = Image({
        src: static_url("/static/images/icons/ajax-loading-small-blue-vfl6t1QvH.gif"),
        srcHiRes: static_url("/static/images/icons/ajax-loading-small-blue@2x-vfl9Zlaal.gif")
      });
      comments = [];
      num_resolved = 0;
      if (this.hasReplies()) {
        _ref = this.props.commentActivity.comment_activities;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          ca = _ref[index];
          if (ca.comment.resolved) {
            num_resolved += 1;
          }
          if (!ca.comment.resolved || this.props.showResolvedComments) {
            isLastComment = index === (this.repliesCount() - 1);
            comments.push(this.renderCommentActivityUI(ca, true, isLastComment));
          }
        }
      }
      return d.div({
        className: "threaded-comment-list"
      }, d.div({}, this.renderCommentActivityUI(this.props.commentActivity, false, !this.hasReplies())), this.hasReplies() ? d.div({}, this.repliesCount() > 1 && this.state.shouldCollapsedReplies ? d.div({}, d.a({
        className: "replies-count-button",
        onMouseDown: this.onToggleReplies
      }, ungettext('%(num)s more comment', '%(num)s more comments', this.repliesCount() - 1).format({
        num: this.repliesCount() - 1
      })), d.div({}, comments[comments.length - 1])) : comments) : void 0, this.state.isNewReplyLoading ? d.div({
        className: "comments-loading"
      }, loadingSpinnerUI) : void 0, this.state.shouldShowReplyInput ? CommentInput({
        ref: "commentInput",
        activity: this.props.activity,
        user: this.props.user,
        onAddComment: this.onAddCommentFromList,
        onCancelComment: this.onCancelComment,
        contactSearchLogger: this.props.contactSearchLogger,
        onAddSticker: this.onAddSticker,
        verifyAfterSignUpCallback: this._verifyAfterSignUpCallback,
        resizeCallback: this.resizeCallback,
        popupsShouldDropdown: this.state.popupsShouldDropdown,
        onFocus: this.onFocus,
        onBlur: this.props.onInputBlur,
        onShowNewComment: this.props.onShowNewComment,
        showNewComment: this.props.showNewComment,
        inBlankState: true,
        enableNotifyText: false,
        enableNoNotifyHint: this.props.enableNoNotifyHint,
        commentMetadataAllowed: GandalfUtil.getGandalfRule("pptx-commenting") || GandalfUtil.getGandalfRule("dw-comments-stickers"),
        enableStickers: GandalfUtil.getGandalfRule("dw-comments-stickers"),
        fileViewerState: this.props.fileViewerState,
        shouldInitiallyFocusInput: false,
        isCommentInputDisabled: this.props.isCommentInputDisabled,
        enableImport: this.props.enableImport,
        shouldHidePhotoAvatars: this.props.shouldHidePhotoAvatars,
        isReplyInput: true
      }) : void 0, d.div({
        className: "threaded-comment-list__divider"
      }, ""));
    }
  });
  return ThreadedCommentActivityUI;
});

//# sourceMappingURL=threaded_comment_activity_ui.map
